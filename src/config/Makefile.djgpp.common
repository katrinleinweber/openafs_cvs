#
# Makefile.djgpp.common
# shared make information for all builds
# requires gmake
#
# Usage: Not designed for direct invocation.
# Please use a Makefile.djgpp instead, which will include this file
# as a resource.
#
# Makefile.djgpp
# A Makefile should define some basics, be in the right directory, then
# include this Makefile.djgpp.common
# Please define
#	TARGETS		a list of executables the Makefile covers (with .exe)
#	target rules	dependencies between an executable and its object files
#	install target	--- to be determined ---
#	all target	list the exported files of the build

#
# VARIABLE SETUP
#

SHELL = /bin/sh
MKDIR = /bin/mkdir -p
CP = /bin/cp -f
MAKE := $(MAKE) -f Makefile.djgpp

.PHONY : install all clean depends
# depends is a phony target even though we have a file by that name
# to hold dependency information, because we want it to be refreshed every
# time a user invokes make depends, regardless of how up-to-date it may appear

# These are the source files that need make depends handling.
#
ifndef SOURCES
SOURCES = $(wildcard *.c) $(wildcard *.s)
endif

# This define is for convenience only, should individual makefiles find
# it useful to have a list of possible object files.
#
# ALL_OBJS = $(patsubst %.c,%.o,$(wildcard *.c)) \
# 	$(patsubst %.s,%.o,$(wildcard *.s))
ALL_OBJS = $(addsuffix .o,$(basename $(SOURCES)))

# These are the directories where built things should end up.
#
DESTINC = DEST/include
DESTINCAFS = DEST/include/afs
DESTLIB = DEST/lib
DESTBIN = DEST/bin

# global flags:  Please set or empty these global flags as needed,
# or append to/modify them in local makefiles for directory-specific behavior.
#
#DEBUGFLAGS = #-g #-pg
	# -Wall
DEBUGFLAGS = -g -DDEBUG
#OPTIMIZEFLAGS = -O2
#OPTIMIZEFLAGS =
INCLUDES = -IDEST/include # -I../client_osi
# includes2 is for compiling components in outer directory
INCLUDES2 = -I../djgpp/include -I../djgpp/client_osi
LIBDIRS = -L$(DESTLIB)
DEFINES = -Dfds_bits=fd_bits
# -DIDRIVE_X86_ENV

# global flags:  These are constructed from other defines.
# Redefine global flags in individual makefiles if needed.
#
CFLAGS = $(DEBUGFLAGS) $(OPTIMIZEFLAGS) $(DEFINES) $(INCLUDES) 
CFLAGS2 = $(DEBUGFLAGS) $(OPTIMIZEFLAGS) $(DEFINES) $(INCLUDES2) 
LDFLAGS = $(DEBUGFLAGS) $(OPTIMIZEFLAGS) $(LIBDIRS)

# We are cross-compiling, so some defaults change...
#
CC = dos-gcc -bmmap
#CC = gcc -bmmap
MAKEDEPEND = $(CC) $(CFLAGS) -M
CPP = $(CC) $(CFLAGS) -E
LD = dos-ld
AS = dos-as
AR = dos-ar
RANLIB = $(AR) -s	# GNU-ranlib = GNU-ar -s

#
# RULES FOR ESSENTIAL TARGETS
#

# make all
#	Builds the files that need to be built
#	Actual files to be built should be listed as dependencies
#	in the Makefile that includes this one.
#	A do-nothing target is listed here to ensure it is the first
#	(default) target.
all : 

# make install
#	Installs the built files in the right place
#	Actual files in their final destinations should be listed
#	as dependencies in the makefile that includes this one.
#	For example, if install needs to copy libwidget.a to $DESTLIB,
#	the makefile should have a line 'install : $(DESTLIB)/libwidget.a'.
#	It may optionally have a body of commands that handle any
#	directory-specific post-processing.
install : all

# make depends
#	Updates dependencies for all source files
#	Must be run by hand whenever dependencies change, or before
#	the very first build
#
depends :
	$(MAKEDEPEND) $(SOURCES) > Makefile.djgpp.depends

# make clean
#	Removes all built files
#
clean :
	-$(RM) -f $(TARGETS) *.o *.ss core

#
# IMPLICIT RULES
#

# new implicit rules install files
# These come first so that the more general rule to create libraries does not
# trump the rule below to install libraries.
#
$(DESTLIB)/%.a : %.a
	[ -d $(DESTLIB) ] || $(MKDIR) $(DESTLIB)
	$(CP) $< $@
#$(DESTLIB2)/%.a : %.a
#	[ -d $(DESTLIB2) ] || $(MKDIR) $(DESTLIB2)
#	$(CP) $< $@
$(DESTINC)/%.h : %.h
	[ -d $(DESTINC) ] || $(MKDIR) $(DESTINC)
	$(CP) $< $@
$(DESTINCAFS)/%.h : %.h
	[ -d $(DESTINC) ] || $(MKDIR) $(DESTINC)
	[ -d $(DESTINCAFS) ] || $(MKDIR) $(DESTINCAFS)
	$(CP) $< $@
# special: djgpp can make .exe and coff file pairs; copy both if possible
$(DESTBIN)/%.exe : %.exe
	[ -d $(DESTBIN) ] || $(MKDIR) $(DESTBIN)
	-[ -r $(basename $<) ] && $(CP) $(basename $<) $(DESTBIN)/
	$(CP) $^ $@

# new implicit rules to handle assembly (.s), AFS-style
# AFS uses %.s -> cpp -> %.ss -> as -> %.o rather than the
# gmake %.S -> cpp -> %.s -> as -> %.o default. 
#
%.ss : %.s
	$(CPP) $(CPPFLAGS) -P -x c-header $< $(OUTPUT_OPTION)
%.o : %.ss
	$(AS) $(ASFLAGS) $< $(OUTPUT_OPTION)

# new implicit rule to create libraries
#
%.a :
	-$(RM) $@
	$(AR) crv $@ $^
	$(RANLIB) $@

# new implicit rule to create executables
#	$(LD) $(LDFLAGS) $^ -o $(basename $@)
%.exe :
	$(CC) $(LDFLAGS) -Wl,-\( $^ -Wl,-\) -o $(basename $@)
	

#
# DEPENDENCY INFORMATION
#

# always request a local dependency list
#
ifeq ($(MAKECMDGOALS),depends)
  DONTDEP=1
endif 
ifeq ($(MAKECMDGOALS),includes)
  DONTDEP=1
endif 
ifneq ($(DONTDEP),1)
include Makefile.djgpp.depends
# ensure a build process breaks if Makefile.djgpp.depends does not exist
#
Makefile.djgpp.depends :
	@echo Please run \"$(MAKE) depends\" to generate dependency information.
	@exit 1
endif
